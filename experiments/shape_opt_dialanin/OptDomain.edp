include "getARGV.idp"

func string padint(int i, int len){ // pad int to given length with zeros
  string ss = i;
  int nn = ss.length; 
  for(int i=0;i<len-nn;i++)
    ss = "0"+ss;
  return ss;
}

/// PHYSICAL CONSTANTS
// The metric tensor  D(z)= E_\mu(\nabla \xi^\top M^{-1}\nabla\xi | \xi=z) has units of mol * g^-1 * Angstrom^-2
// The effective generator is given by \e^(\beta F)\div(\e^(-\beta F)D\nabla)/(beta*friction), where the gradients are in dimensionless CV space
// and D is the metric tensor. Therefore, its eigenvalues have units of
// 1  (mol * g^-1 * Angstrom^-2) * (kcal * mol^-1) * ps = 418.4 * ps^-1

real beta = 1.677; // mol * kcal^-1
real friction = 1.0; // ps^-1
real convfactor = 418.4;

real[int,int] minima = [[-2.4609142453120048, 0.10471975511965978],
 [-1.2042771838760873, -0.24434609527920614],
 [-2.5656340004316642, 2.8623399732707004],
 [-1.1344640137963142, 2.722713633111154],
 [0.9250245035569946, 0.4886921905584123],
 [0.9948376736367679, 3.141592653589793]]; // rad, free-energy local minima

 real GR = (1+sqrt(5.0))/2; // golden ratio, for Fibonacci lattice

////


int minind = getARGV("--minind",4); // index of the free-energy minimum to optimize around
int maxiter = getARGV("--maxiter",8000); // maximal number of optimization steps (line searches)
int ndigitsIter = 1+floor(log10(maxiter));

real hmax = getARGV("--hmax",0.03); // for mesh adaptation
real lr = getARGV("--lr",1e-3); // time step
real lrmin = getARGV("--lrmin",1e-5); // minimal time step
real epsreg = getARGV("--epsreg",sqrt(0.1)); // extension-regularization parameter
real lrmult = getARGV("--lrmult",0.8); // time step multiplier
int plotFreq = getARGV("--plotfreq",1); //frequency of plots
real hmin = hmax/10;
bool plots = getARGV("--plots",1); // whether to plot or not
real epsTerm = getARGV("--epsterm",1.0e-10); // stopping criterion on relative change in the objective function
real slopeTerm = getARGV("--gradterm",5e-3); // stopping criterion on (analytical) directional derivative
real epsNorm = getARGV("--epsNorm",0.0); // epsilon to normalize search direction in L^2(boundary)

real rphi = getARGV("--rphi",0.3); // phi semi-axis of coresets (radians)
real rpsi = getARGV("--rpsi",0.3); // psi semi-axis
real clamptol = getARGV("--clamptol",0.01); // when to consider eigenvalue is degenerate (|l-l'|/l' < clamptol)
int nsearch = getARGV("--nsearch",1000); // number of points on Fibonnaci lattice if fullSearch, else number of sampled angles
bool fullSearch = getARGV("--fullsearch",1); // if on, in the degenerate case, does the full search on the sphere, else searches on the circle generated by the diagonal elements

// center of initial domain, in radians (by default the minimum indexed by minind)
real phi0 = getARGV("--phi0",minima(minind,0)); 
real psi0 = getARGV("--psi0",minima(minind,1));

real normThreshold = getARGV("--normthreshold",2.0); // threshold for ascent perturbation normalization


// Parameters and macros for regularization extension problem -- some taken from https://github.com/flomnes/optiflow/
/* Transpose of M */
macro tr(M) M' //EOM
/* Divergence of u */
macro div(u, v) (dx(u)+dy(v)) // EOM
/* (Scalar) tangential derivative of a scalar function u */
macro grad(u) [dx(u), dy(u)] // EOM
/* u \cdot n for a vector function u=(u1,u2) */
macro gradT(u) (grad(u) - grad(u)'*[N.x, N.y]*[N.x, N.y]) // EOM
/* (Vector) gradient of a scalar function u */
macro dotN(u1,u2) (u1*N.x+u2*N.y) //EOM
/* Jacobian matrix */
macro Jac(u, v) [dx(u), dy(u), dx(v), dy(v)] // EOM
/* normal derivative */
macro dN(u) dotN(dx(u),dy(u)) // EOM

/* Scalar product for extension-regularization -- other choices can be implemented here */
macro dotReg(ux,uy,vx,vy) int2d(Th)(epsreg^2 * tr(Jac(ux,uy))*Jac(vx,vy) + [ux,uy]'*[vx,vy]) // EOM


/* macro to save boundary geometry */
macro writeBoundary(fname) ofstream fout(fname);
  for(int k=0;k<Th.nbe;k++){
    fout << Th(Th.be(k)[0]).x << " " <<Th(Th.be(k)[0]).y<<" "<<Th(Th.be(k)[1]).x << " " << Th(Th.be(k)[1]).y << endl;
  } // EOM

bool frommesh = getARGV("--frommesh",0);
string logpath = getARGV("--logpath","./logs/"); // path to store log files
string impath = getARGV("--imgpath","./imgs/"); // path to store the plots
string prefix = getARGV("--prefix",""); // prefix to prepend to every output file
string meshfile = getARGV("--meshfile",""); //if frommesh is set to true

// make folder hierarchy for output
system("mkdir -p  "+logpath);
system("mkdir -p "+impath+"/V/");
system("mkdir -p "+impath+"/u1/");
system("mkdir -p "+impath+"/u2/");
system("mkdir -p "+impath+"/theta/");
system("mkdir -p "+logpath+"/meshhist/"+minind+"/");
system("mkdir -p "+logpath+"/opt_meshes/");
system("mkdir -p "+logpath+"/checkpoints/");

ofstream logfile(logpath+prefix+"_log_"+beta+"_"+minind+".out");

logfile << "# ITERATION LAMBDA1 LAMBDA2 LAMBDA3 LAMBDA4 NORMTHETA SLOPE NLINESEARCH TIMESTEP" << endl;
int nev=4; // number of eigvals to compute

// INPUT METRIC DATA & FREE ENERGY

ifstream a11File("upa11.out");
ifstream a22File("upa22.out");
ifstream a12File("upa12.out");
ifstream pmfFile("uppmf.out");

int sizeMat = 720;

real[int,int] a11Mat(sizeMat,sizeMat); // deg^2 * mol * g^-1 * Angstrom^-2
real[int,int] a22Mat(sizeMat,sizeMat);
real[int,int] a12Mat(sizeMat,sizeMat);
real[int,int] pmfMat(sizeMat,sizeMat); // kcal * mol^-1

for(int i=0;i<sizeMat;i++){
  for(int j=0;j<sizeMat;j++){
    a11File >> a11Mat(i,j);
    a22File >> a22Mat(i,j);
    a12File >> a12Mat(i,j);
    pmfFile >> pmfMat(i,j);
  }
}

real twopi = 2*pi;

// convert arrays to rad
real const = (twopi/360)^2;

a11Mat *= const;
a12Mat *= const;
a22Mat *= const;

real phimin =  -4.101523742186674;
real phimax = 2.181661564992912;
real psimin = -2.0943951023931953;
real psimax = 4.1887902047863905;

macro binphi(t) floor(sizeMat*(t-phimin-twopi*floor((t-phimin)/twopi))/(phimax-phimin)) // EOM
macro binpsi(t) floor(sizeMat*(t-psimin-twopi*floor((t-psimin)/twopi))/(psimax-psimin)) // EOM

func a11 = a11Mat(binphi(x),binpsi(y));
func a12 = a12Mat(binphi(x),binpsi(y));
func a22 = a22Mat(binphi(x),binpsi(y));
func pmf = pmfMat(binphi(x),binpsi(y));
func mu = exp(-beta*pmf);

// geometry
//
int nBoundary = 150; //number of points on the boundary

mesh Th;

if(!frommesh){
  border dOmega(t=0,2*pi){x = phi0+rphi*cos(t); y = psi0+rpsi*sin(t); label=1;};
  Th = buildmesh(dOmega(nBoundary));
  Th = adaptmesh(Th,hmax=hmax,hmin=hmin,nbvx=100000);
}
else{
  Th = readmesh(meshfile);
}

fespace Vh(Th,P1);
Vh a11h = a11;
Vh a22h = a22;
Vh a12h = a12;
Vh pmfh = pmf;
Vh muh = mu;


plot(a11h,wait=true,fill=true,value=true);
// implement 

// // FE spaces and variables
fespace Vhvec(Th,[P1,P1]); // for shape perturbations

matrix A,B ;  // fem matrices
matrix At,Bt;

real[int] evalues(nev); // eigenvalues
Vh[int] evectors(nev); // eigenvectors

Vhvec [thetax,thetay]; // shape gradient extension variables

int iter = 0;
real eta; // step size

int k;
real J,Jmax;
Jmax = -1;
J = -1;
real newJ;

string checkpath = logpath+"/checkpoints/"+prefix+"_"+minind+".msh";
savemesh(Th,checkpath); // checkpoint mesh

int ndegenit = 0;


real mesharea;

ofstream debuglog("debug.log");
debuglog << "# L*(sphere) a* b* c* L*(circle) a* b*" << endl;

real normTheta,slope;
slope = 1.0; // analytical directional derivative of objective function

while(iter < maxiter){

    cout << "Iteration" << iter << " "<< slope << endl;
    a11h = a11;
    a22h = a22;
    a12h = a12;
    pmfh = pmf;
    muh = mu;

    varf a(u,v) = int2d(Th)((dx(u)*dx(v)*a11h+dy(u)*dy(v)*a22h +(dx(u)*dy(v)+dx(v)*dy(u))*a12h)*muh/beta) + on(1,u=0); // lhs for Dirichlet eigenproblem (with metric tensor)
    varf b(u,v) = int2d(Th)(u*v*muh); // variational rhs
    
    A = a(Vh,Vh,solver=sparsesolver);
    B = b(Vh,Vh,solver=sparsesolver);

    k = EigenValue(A,B,sym=true,sigma=0.0,value=evalues,vector=evectors,tol=1e-10,maxit=0); // compute eigenvalues
    newJ = evalues[1]/evalues[0];
    Jmax = max(newJ,Jmax);

    if(abs((newJ-J)/J)<epsTerm){
      cout << "Iteration "<<iter<<": relative change stopping criterion met. Aborting." << endl;
      break;
    }

    if(slope < slopeTerm){
      cout << "Iteration "<<iter<<": directional derivative criterion met. Aborting" << endl;
      break;
    }

    J = newJ;

    logfile << iter << " ";

    logfile << evalues[0] * convfactor / friction << " ";
    logfile << evalues[1] * convfactor / friction << " ";
    logfile << evalues[2] * convfactor / friction << " ";
    logfile << evalues[3] * convfactor / friction << " ";

    real L1 = evalues[0];
    real L2 = evalues[1];
    real L3 = evalues[2];
    real L4 = evalues[3];


    real normsqTheta;

    ////// SEARCH FOR OPTIMAL DESCENT DIRECTION /////

    func weight = -(muh/beta)*(a11h*N.x^2+a22h*N.y^2+2*a12h*N.x*N.y);
    func dL1 = weight*dN(evectors[0])^2;


    Vhvec [psix,psiy]; // test function

    // tradeoff: regularize search space and find optimum (guarantees on descent) vs regularize analytic optimum after search (cheaper, but only asymptotic guarantee)

    if((L3-L2)/L2 < clamptol){ // DEGENERATE CASE

         varf bdotReg([ux,uy],[vx,vy]) = dotReg(ux,uy,vx,vy);
         matrix Areg = bdotReg(Vhvec,Vhvec,solver=sparsesolver); // Gram matrix for regularization dot-product

         ndegenit++;

         ofstream degenlog("degen_log/"+prefix+"_"+ndegenit+".out");
         degenlog << "# IT FIBIT X Y Z RATE DISCRIMINANT" << endl;

          if((L4-L2)/L2 < clamptol){
            cout << "ERROR : second eigenvalue has multiplicity > 2. Aborting." << endl; // we do not handle triple degenaracies
            exit(1);
          }

          cout << "(L3-L2)/2 < " << clamptol << " : Commencing spherical search" << endl;

          func dL2one = weight*dN(evectors[1])^2;
          func dL2two = weight*dN(evectors[2])^2;
          func dL2mix = weight*dN(evectors[1])*dN(evectors[2]);

          // Basis of representants for optimal subspace in L^2(\partial\Omega)
          func v1boundary = -dL1*L2/L1^2 + dL2one/L1;
          func v2boundary = -dL1*L2/L1^2 + dL2two/L1;
          func v3boundary = dL2mix/L1;

          real bestlam=-100.0;

          real m11,m12,m22;

          real[int,int] G(3,3); // basis coefficients for shape-variation matrix

          Vhvec [v1x,v1y],[v2x,v2y],[v3x,v3y]; // for extension-regularization of matrix components
          Vhvec [u1x,u1y],[u2x,u2y]; // for orthonormalization

          varf rhsv1([ux,uy],[vx,vy]) = int1d(Th,1)(v1boundary*dotN(vx,vy));
          varf rhsv2([ux,uy],[vx,vy]) = int1d(Th,1)(v2boundary*dotN(vx,vy));

          real[int] b1 = rhsv1(0,Vhvec);
          real[int] b2 = rhsv2(0,Vhvec);

          v1x[] = Areg^-1 * b1; // factorizes Areg
          v2x[] = Areg^-1 * b2; // fast

            // Gram-Schmidt (stable version)
            real normv1 = sqrt(dotReg(v1x,v1y,v1x,v1y));
            u1x[] = v1x[]/(epsNorm+normv1); // in FreeFem++, u1x[] refers to DOFs of [u1x,u1y]

            real u1dotv2 = dotReg(u1x,u1y,v2x,v2y);
            v2x[] -= u1dotv2 * u1x[];

            real normv2perp = sqrt(dotReg(v2x,v2y,v2x,v2y));
            u2x[] = v2x[] / (epsNorm+normv2perp);

            // compute common components
            G(0,0) = int1d(Th,1)(v1boundary*dotN(u1x,u1y));
            G(1,0) = int1d(Th,1)(v1boundary*dotN(u2x,u2y));

            G(0,1) = int1d(Th,1)(v2boundary*dotN(u1x,u1y));
            G(1,1) = int1d(Th,1)(v2boundary*dotN(u2x,u2y));

            G(0,2) = int1d(Th,1)(v3boundary*dotN(u1x,u1y));
            G(1,2) = int1d(Th,1)(v3boundary*dotN(u2x,u2y));

          if(fullSearch){ // SPHERICAL SEARCH

            Vhvec [v3x,v3y],[u3x,u3y];
            
            varf rhsv3([ux,uy],[vx,vy]) = int1d(Th,1)(v3boundary*dotN(vx,vy));
            real[int] b3 = rhsv3(0,Vhvec);
            v3x[] = Areg^-1 * b3; // fast

            // finish Gram-Schmidt
            real u1dotv3 = dotReg(u1x,u1y,v3x,v3y);
            v3x[] -= u1dotv3 * u1x[];

            real u2dotv3 = dotReg(u2x,u2y,v3x,v3y);
            v3x[] -= u2dotv3 * u2x[];

            real normv3perp = sqrt(dotReg(v3x,v3y,v3x,v3y));
            u3x[] = v3x[]/(epsNorm+normv3perp);


            cout << "Sanity check : Gram Matrix :" << endl;

            cout << "| " << dotReg(u1x,u1y,u1x,u1y) <<" "<<dotReg(u1x,u1y,u2x,u2y) << " "<<dotReg(u1x,u1y,u3x,u3y) <<" |" <<endl;
            cout << "| " << dotReg(u2x,u2y,u1x,u1y) <<" "<<dotReg(u2x,u2y,u2x,u2y)<<" "<<dotReg(u2x,u2y,u3x,u3y)<<" |" <<endl;
            cout << "| " << dotReg(u3x,u3y,u1x,u1y) <<" "<<dotReg(u3x,u3y,u2x,u2y)<<" "<<dotReg(u3x,u3y,u3x,u3y)<<" |" <<endl;

            cout << "Sanity check : u3 normalization :" << normv3perp << endl;

                // compute missing coefficients
                G(2,0) = int1d(Th,1)(v1boundary*dotN(u3x,u3y));
                G(2,1) = int1d(Th,1)(v2boundary*dotN(u3x,u3y));
                G(2,2) = int1d(Th,1)(v3boundary*dotN(u3x,u3y));

                // Grid search on sphere

                real bestdiscr = 0.0;

                int bestifib = 0;

                // sample sphere using Fibonnacci lattice
                real alph,bet,gamm,thet,csqrtgamm;

                for(int ifib=0;ifib<nsearch;ifib++){
                        gamm = 1.0-(2.0*ifib+1)/nsearch; // z
                        thet = 2*pi*ifib/GR;
                        csqrtgamm = sqrt(1-gamm^2);
                        alph = csqrtgamm*cos(thet); // x
                        bet = csqrtgamm*sin(thet); // y

                         m11 = alph*G(0,0)+bet*G(1,0)+gamm*G(2,0);
                         m22 = alph*G(0,1)+bet*G(1,1)+gamm*G(2,1);
                         m12 = alph*G(0,2)+bet*G(1,2)+gamm*G(2,2);

                        real lam = (m11 + m22 - sqrt((m11-m22)^2 + 4*m12^2))/2;

                        if(lam>bestlam){
                            bestlam = lam;
                            bestifib = ifib;
                            bestdiscr = (m11-m22)^2 + 4*m12^2;
                        }

                        degenlog << iter << " " << ifib << " " << alph << " " << bet << " " << gamm << " " << lam << " " << (m11-m22)^2 + 4*m12^2 << endl;

                        // cout << "Spherical search, iteration " << ifib << " current lam :" << lam << " best lam : " << bestlam << " best ifib: " << bestifib << " best discriminant: " << bestdiscr << endl;
                    }

                gamm = 1.0-(2.0*bestifib+1)/nsearch; // z
                thet = 2*pi*bestifib/GR;
                csqrtgamm = sqrt(1-gamm^2);
                alph = csqrtgamm*cos(thet); // x
                bet = csqrtgamm*sin(thet); // y

              [thetax,thetay] = alph*[u1x,u1y] + bet*[u2x,u2y]+gamm*[u3x,u3y];

          }
          else{ // CIRCLE SEARCH
            cout << "Sanity check : Gram Matrix :" << endl;

            cout << "| " << dotReg(u1x,u1y,u1x,u1y) <<" "<<dotReg(u1x,u1y,u2x,u2y) <<" |" <<endl;
            cout << "| " << dotReg(u2x,u2y,u1x,u1y) <<" "<<dotReg(u2x,u2y,u2x,u2y)<<" |" <<endl;

            cout << "Sanity check : u2 normalization :" << normv2perp << endl;

                // Grid search on circle

                real bestdiscr = 0.0;
                real bestlam = -100.0;
                real bestt = 0;

                real alph,bet;

                for(real t=0;t<2*pi;t+=2*pi/nsearch){
                        alph = cos(t);
                        bet = sin(t);

                        m11 = alph*G(0,0)+bet*G(1,0);
                        m22 = alph*G(0,1)+bet*G(1,1);
                        m12 = alph*G(0,2)+bet*G(1,2);

                        real lam = (m11 + m22 - sqrt((m11-m22)^2 + 4*m12^2))/2;

                        if(lam>bestlam){
                            bestlam = lam;
                            bestt = t;
                            bestdiscr = (m11-m22)^2 + 4*m12^2;
                        }

                        degenlog << iter << " " << t << " " << alph << " " << bet << " " << " " << lam << " " << (m11-m22)^2 + 4*m12^2 << endl;

                        // cout << "Spherical search, iteration " << ifib << " current lam :" << lam << " best lam : " << bestlam << " best ifib: " << bestifib << " best discriminant: " << bestdiscr << endl;
                    }

                alph = cos(bestt); // z
                bet = sin(bestt);

              thetax[] = alph*u1x[] + bet*u2x[];
          }

        slope =  bestlam;
        normTheta = 1.0;

    }
    else{ // NON-DEGENERATE CASE
          func dL2 = weight*(dx(evectors[1])*N.x+dy(evectors[1])*N.y)^2;
          func phi = -dL1*L2/L1^2 + dL2/L1; // shape gradient of (lambda2/lambda1) wrt flat L^2 scalar product on the boundary.
          solve extension([thetax,thetay],[psix,psiy]) = dotReg(thetax,thetay,psix,psiy) -int1d(Th,1)(phi*dotN(psix,psiy));
          normsqTheta = dotReg(thetax,thetay,thetax,thetay);
          normTheta = sqrt(normsqTheta);
          thetax[] /= max(normThreshold,normTheta); // normalize in H (up to threshold)
          slope = int1d(Th,1)(phi*dotN(thetax,thetay)); // (analytical) directional derivative in the direction theta
    }

    logfile << normTheta << " " << slope << " ";

    int nsteps = 0;
    mesh Thtmp = Th;

    if((iter % plotFreq == 0) && plots){
      Vh gradnormh = sqrt([thetax,thetay]'*[thetax,thetay]);
      plot(evectors[0],value=true,fill=true,boundary=true,ps = impath + "/u1/" + prefix +"_"+ padint(iter,4) + "_" + beta+".eps");
      plot(evectors[1],value=true,fill=true,boundary=true,ps = impath + "/u2/" + prefix +"_"+padint(iter,4)+"_"+beta+".eps" );
      plot(pmfh,value=true,fill=true,boundary=true,ps = impath + "/V/" + prefix +"_"+padint(iter,4)+"_"+beta+".eps" );
      plot(gradnormh,boundary=true,value=true,fill=true,ps = impath + "/theta/" + prefix +"_"+padint(iter,4)+"_"+beta+".eps" );
    }

    eta = lr;
    bool foundStep = false;

    while(!foundStep && (eta>lrmin)){ 
      nsteps +=1;
      real Amin = checkmovemesh(Thtmp,[x+eta*thetax,y+eta*thetay]); // check if move is legal

      if(Amin>0){// replace by local ascent condition if need be
        foundStep = true;
        break;
      }
      else{ // otherwise, adapt mesh
        eta *= lrmult; // decrease step size
      }
    }

    if(!foundStep){
      cout << "Iteration "<<iter<<": failed to find a valid step. Aborting." << endl;
      break;
    }
    else{
      logfile << nsteps << " " << eta << endl;
      Th = movemesh(Thtmp,[x+eta*thetax,y+eta*thetay]);
      Th = adaptmesh(Th,hmax=hmax,hmin=hmin,nbvx=100000);
    }
    iter++;

    logfile.flush;
    writeBoundary(logpath+"meshhist/"+minind+"/"+prefix+"_"+beta+"_"+padint(iter,ndigitsIter)+".out"); // save boundary
    savemesh(Th,checkpath); // checkpoint mesh

}

savemesh(Th,logpath+"opt_meshes/"+minind+".msh"); // save final mesh